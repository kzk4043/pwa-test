# プッシュ通知の仕組み

## Web Push Protocolの概要

Web Push Protocolは、ウェブアプリケーションがユーザーのデバイスにプッシュ通知を送信するための標準仕様です。Service WorkerとPush APIを組み合わせて実現されます。

## プッシュ通知の全体アーキテクチャ

```
[アプリサーバー] → [プッシュサービス] → [ブラウザ] → [Service Worker] → [通知表示]
      ↑              ↑                ↑              ↑
    VAPID キー    Push Protocol    Subscription   Notification API
```

### 関係者の役割

1. **アプリサーバー（あなたのサーバー）**
   - プッシュ通知の送信タイミングを決定
   - プッシュサービスにメッセージを送信

2. **プッシュサービス（ブラウザ提供）**
   - Chrome: FCM (Firebase Cloud Messaging)
   - Firefox: Mozilla AutoPush
   - Safari: Apple Push Service

3. **ユーザーのブラウザ**
   - プッシュメッセージを受信
   - Service Workerを起動

4. **Service Worker**
   - プッシュイベントを処理
   - 通知を表示

## プッシュ通知の実装フロー

### 1. 通知許可の取得

```javascript
// ユーザーに通知許可を要求
const permission = await Notification.requestPermission();

if (permission === 'granted') {
  console.log('通知許可を取得');
} else if (permission === 'denied') {
  console.log('通知許可が拒否されました');
} else {
  console.log('通知許可が保留されました');
}
```

### 2. プッシュサブスクリプションの作成

```javascript
// Service Worker準備完了後
const registration = await navigator.serviceWorker.ready;

// プッシュサブスクリプションを作成
const subscription = await registration.pushManager.subscribe({
  userVisibleOnly: true,  // ユーザーに見える通知のみ
  applicationServerKey: convertVapidKey(vapidPublicKey)
});

console.log('サブスクリプション:', subscription.toJSON());
```

#### サブスクリプション内容
```javascript
{
  "endpoint": "https://fcm.googleapis.com/fcm/send/...",
  "keys": {
    "p256dh": "BK...", // 公開鍵
    "auth": "Ab..."     // 認証秘密鍵
  }
}
```

### 3. サーバーへのサブスクリプション送信

```javascript
// サブスクリプション情報をサーバーに送信
const response = await fetch('/api/push/subscribe', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(subscription.toJSON())
});

if (response.ok) {
  console.log('サブスクリプション登録完了');
}
```

### 4. サーバー側でのプッシュ送信

```javascript
// Node.js + web-push ライブラリの例
const webpush = require('web-push');

// VAPIDキーの設定
webpush.setVapidDetails(
  'mailto:your-email@example.com',
  vapidPublicKey,
  vapidPrivateKey
);

// プッシュ通知送信
const payload = JSON.stringify({
  title: '新しいメッセージ',
  body: 'PWAから通知が届きました',
  icon: '/icons/icon-192x192.png',
  badge: '/icons/icon-72x72.png',
  data: {
    url: '/messages/123'
  }
});

webpush.sendNotification(subscription, payload)
  .then(result => console.log('送信成功:', result))
  .catch(error => console.error('送信失敗:', error));
```

### 5. Service Workerでの通知受信

```javascript
// sw.js
self.addEventListener('push', event => {
  console.log('プッシュメッセージ受信');

  let notificationData = {
    title: 'デフォルトタイトル',
    body: 'デフォルトメッセージ',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-72x72.png'
  };

  // プッシュデータがある場合
  if (event.data) {
    const data = event.data.json();
    notificationData = { ...notificationData, ...data };
  }

  // 通知を表示
  event.waitUntil(
    self.registration.showNotification(
      notificationData.title,
      {
        body: notificationData.body,
        icon: notificationData.icon,
        badge: notificationData.badge,
        vibrate: [200, 100, 200],
        data: notificationData.data,
        actions: [
          {
            action: 'open',
            title: '開く',
            icon: '/icons/icon-192x192.png'
          },
          {
            action: 'close',
            title: '閉じる'
          }
        ]
      }
    )
  );
});
```

### 6. 通知クリック時の処理

```javascript
// 通知クリック時の処理
self.addEventListener('notificationclick', event => {
  console.log('通知がクリックされました:', event.action);

  // 通知を閉じる
  event.notification.close();

  // アクションに応じて処理
  if (event.action === 'open') {
    // アプリを開く
    event.waitUntil(
      clients.openWindow(event.notification.data.url || '/')
    );
  }
  // 'close' アクションや通知本体クリックの場合は何もしない
});
```

## VAPIDキー（Voluntary Application Server Identification）

### VAPIDとは
- アプリサーバーの身元確認のための仕組み
- プッシュサービスがメッセージの送信元を検証
- スパム防止とセキュリティ向上

### VAPIDキーの生成

```javascript
// Node.js での生成例
const webpush = require('web-push');

const vapidKeys = webpush.generateVAPIDKeys();
console.log('Public Key:', vapidKeys.publicKey);
console.log('Private Key:', vapidKeys.privateKey);
```

```bash
# コマンドラインでの生成
npx web-push generate-vapid-keys
```

### VAPIDキーの使用

```javascript
// サーバー側設定
webpush.setVapidDetails(
  'mailto:your-email@example.com',  // 連絡先メールアドレス
  'BK7dTqw...vapidPublicKey',       // VAPID公開鍵
  'W8Ym3bR...vapidPrivateKey'       // VAPID秘密鍵
);

// クライアント側でサブスクリプション作成時に公開鍵を使用
const subscription = await registration.pushManager.subscribe({
  userVisibleOnly: true,
  applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)
});
```

## FCM vs 標準Web Push

### FCM（Firebase Cloud Messaging）
```javascript
// FCM使用時の実装例
const messaging = firebase.messaging();

// トークン取得
const token = await messaging.getToken({
  vapidKey: 'BK7dTqw...vapidPublicKey'
});

// メッセージ受信
messaging.onMessage((payload) => {
  console.log('メッセージ受信:', payload);
});
```

**メリット**:
- Google提供の安定したサービス
- 詳細な送信統計
- トピック配信機能

**デメリット**:
- Googleサービス依存
- 追加のSDK必要

### 標準Web Push
**メリット**:
- ベンダー中立
- 標準仕様準拠
- 軽量な実装

**デメリット**:
- 送信統計が限定的
- 高度な機能が少ない

## 必要なAPIエンドポイント設計

### 1. サブスクリプション登録
```http
POST /api/push/subscribe
Content-Type: application/json

{
  "endpoint": "https://fcm.googleapis.com/fcm/send/...",
  "keys": {
    "p256dh": "BK...",
    "auth": "Ab..."
  }
}
```

### 2. サブスクリプション削除
```http
DELETE /api/push/unsubscribe
Content-Type: application/json

{
  "endpoint": "https://fcm.googleapis.com/fcm/send/..."
}
```

### 3. 通知送信（管理用）
```http
POST /api/push/send
Content-Type: application/json
Authorization: Bearer admin-token

{
  "title": "通知タイトル",
  "body": "通知メッセージ",
  "data": {
    "url": "/target-page"
  },
  "targets": ["user1", "user2"] // または "all"
}
```

### 4. 送信履歴取得
```http
GET /api/push/history?limit=50
Authorization: Bearer admin-token
```

## 本プロジェクトでの実装

### クライアント側の実装（push.js）

```javascript
// 通知許可とサブスクリプション作成
async function subscribeToPush() {
  const registration = await navigator.serviceWorker.ready;
  
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true,
    // 実際の実装ではVAPID公開鍵を設定
    // applicationServerKey: convertVapidKey(vapidPublicKey)
  });

  // サーバーに送信（実際の実装では）
  // await sendSubscriptionToServer(subscription);
  
  // テスト版ではローカルストレージに保存
  localStorage.setItem('push-subscription', 
    JSON.stringify(subscription.toJSON()));
}
```

### Service Worker側の実装（sw.js）

```javascript
// プッシュ通知受信
self.addEventListener('push', event => {
  const options = {
    body: 'プッシュ通知のテストです',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-72x72.png',
    vibrate: [200, 100, 200],
    data: { timestamp: Date.now() },
    actions: [
      { action: 'open', title: '開く' },
      { action: 'close', title: '閉じる' }
    ]
  };

  event.waitUntil(
    self.registration.showNotification('PWAテスト', options)
  );
});
```

## プッシュ通知のベストプラクティス

### 1. ユーザー体験の向上
```javascript
// 適切なタイミングで許可要求
// ユーザーがアプリの価値を理解した後
if (userEngaged && !hasAskedPermission) {
  requestNotificationPermission();
}
```

### 2. 通知内容の最適化
```javascript
const notification = {
  title: '簡潔でわかりやすいタイトル（50文字以内）',
  body: '有用な情報を含む本文（150文字以内）',
  icon: '/icons/icon-192x192.png', // 192x192推奨
  badge: '/icons/icon-72x72.png',  // 72x72以下
  image: '/images/notification-image.jpg', // 任意
  vibrate: [200, 100, 200], // Android向け
  silent: false, // サイレント通知は避ける
  requireInteraction: false // 重要でない限りfalse
};
```

### 3. 通知頻度の制御
```javascript
// 最後の通知から一定時間は送信しない
const NOTIFICATION_COOLDOWN = 1000 * 60 * 60; // 1時間

function canSendNotification(userId) {
  const lastSent = getLastNotificationTime(userId);
  return Date.now() - lastSent > NOTIFICATION_COOLDOWN;
}
```

### 4. エラーハンドリング
```javascript
webpush.sendNotification(subscription, payload)
  .catch(error => {
    if (error.statusCode === 410) {
      // サブスクリプション無効 - 削除
      removeSubscription(subscription.endpoint);
    } else if (error.statusCode === 413) {
      // ペイロードサイズ過大
      console.error('ペイロードが大きすぎます');
    } else {
      console.error('送信エラー:', error);
    }
  });
```

## トラブルシューティング

### よくある問題

1. **通知が表示されない**
   - 通知許可の確認
   - Service Worker の登録状態確認
   - HTTPSでの実行確認

2. **サブスクリプション作成失敗**
   - VAPIDキーの形式確認
   - ブラウザサポート状況確認
   - ネットワーク接続確認

3. **プッシュ送信失敗**
   - サブスクリプションの有効性確認
   - VAPIDキーの設定確認
   - ペイロードサイズ確認（4KB以下）

### デバッグ方法

```javascript
// サブスクリプション情報の確認
navigator.serviceWorker.ready.then(registration => {
  registration.pushManager.getSubscription().then(subscription => {
    console.log('現在のサブスクリプション:', subscription);
  });
});

// 通知履歴の確認（Chrome DevTools）
// Application > Notifications
```

プッシュ通知は複雑な仕組みですが、適切に実装することでユーザーエンゲージメントを大きく向上させることができます。セキュリティとユーザー体験の両方を考慮した実装を心がけましょう。